<p>
    lambda prime is a system of computation (or smth) that i created a while ago and just
    recently dug up again. is it useful? not really. is it any different from lambda calculus?
    probably not. but it is kinda interesting, so here it is:
</p>
<p>
    instead of numbers or smth, all literals are objects, written as `(T param*)`, where `T` is the
    type name and `param` is either variable, or another literal. there are two operators for objects:
    `?` and `!`. `(T x)?` has two meanings: if used as an expression, it returns true if the object
    with type `T` and parameters `(x)` exists. if used as a standalone statement, it declares that that
    object exists. `!` is the same, but for nonexistence. writing `(T x)!` as a standalone statement declares
    that the object `(T x)` does not exist. `(T x)!` as an expression checks if `(T x)` exists.
</p>
<p>
    there is one special object, `M`: it is used for pattern matching. if an object `(M x y)` exists, then `y`
    matches the pattern `x`. the definition of `M` is:
</p>
<pre>
(M x x)?
(M x y)!
</pre>
<p>
    this just says that for all values of `x`, `(M x x)` exists, but `(M x y)` does not, for all values of `y`
    distinct from `x`.
</p>
<p>
    now we get to `\'`, the lambda prime combinator. it is written as follows:
</p>
<pre>
              / y    if (Max)?
(\'x.y.z).a = |
              \ z    if (Max)!
</pre>
<p>
    here, `.` is the function application operator. thus, lambda prime acts as an if statement of sorts: it compares
    `x` and `a`, using `y` as the `then` branch and `z` as the `else`.
</p>
<p>
    lambda prime can be shown to be equivalent to lambda calculus this way:
</p>
<pre>
xy = x.y
\x.y = (\'(Mx).y.(N))
</pre>
<p>
    here `N` is used to represent a nil type, but anything can be used.
</p>
<h2>footnote: stack stuff</h2>
<p>
    we can implement a simple stack in lambda prime. first we must define a generic pair type:
</p>
<pre>
(P x y)?
</pre>
<p>
    then we can define the stack itself:
</p>
<pre>
(St x y)?
(Bt x)?
(Ps x) = (\' (M a).(St x a).N)
(Po) = (\' (M (St x y)).(P x y).N)
</pre>
<p>
    this defines several objects: `(St x y)`, a `head:tail` like stack and `(Bt x)`, representing the bottom of a stack. a full
    stack might be, for example:
</p>
<pre>
(St 1 (St 2 (St 3 (Bt 4)))) 
</pre>
<p>
    then we have `(Ps x)`, the push operation. it is both an object and a function: think of it like a generic. it is used as follows:
</p>
<pre>
(Ps item).stack
</pre>
<p>
    it returns a new stack, with `item` at the top.
</p>
<p>
    then we have the `(Po)` operation. It is applied to a stack, and returns a pair: the first element is the popped item, the second is
    the new stack.
</p>
